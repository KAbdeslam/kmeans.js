var Vector = require('./vector');

// 1. Randomly select K points (called means)
// 2. Assign each observation to the cluster with the closest mean 

var kmeans = {};

kmeans.k = function(k) { kmeans._k = k; return this; /*for chaining*/ }

kmeans.process = function(observations) {
  var k = kmeans._k;
  var dimension = observations[0].getDimension();
  // Randomly select k means
  // Find x,y,z,... boundaries
  var min_boundary = observations[0].getComponents().slice(0); // slice(0) -> copy array, dont pass by reference
  var max_boundary = observations[0].getComponents().slice(0);
  for(var i in observations) {
    for(var j in observations[i].getComponents()) {
      var c = observations[i].getComponents()[j];
      if(c < min_boundary[j]) min_boundary[j] = c;
      if(c > max_boundary[j]) max_boundary[j] = c;
    }
  }

  console.log('Min boundary: ' + min_boundary);
  console.log('Max boundary: ' + max_boundary);
  // Boundaries min,max found. Select k random points within boundary.
  var means = [];
  for(var i = 0; i < k; i++) {
    var random_point = [];
    for(var j = 0; j < dimension; j++) {
      var min = min_boundary[j];
      var max = max_boundary[j];
      var c = min + Math.random() * (max - min); // number between min-max
      random_point.push(c);
    }
    means.push(new Vector(random_point));
  }

  console.log('Randomly generated means: ');
  console.log(means);

  // Initialize cluster containers
  var clusters = [];
  for(var i = 0; i < k; i++) {
    clusters.push([]);
  }

  // Assignment step: Assign each observation to the cluster with the closest mean (i.e. partition the observations according to the Voronoi diagram generated by the means).
  for(var i in observations) {
    var v = observations[i];
    // Compare distance with all means
    var smallest_distance = v.getDistanceTo(means[0]);
    var closest_mean = 0;
    for(var j = 1; j < means.length; j++) {
      var distance = v.getDistanceTo(means[j]);
      if(distance < smallest_distance) {
        smallest_distance = distance;
        closest_mean = j;
      }
    }
    clusters[closest_mean].push(v);
  }

  return {means: means, clusters: clusters};
}

module.exports = kmeans;
